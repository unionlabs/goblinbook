<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Dispatching an Asset Transfer - Interop: Principles, Techniques, and Tools</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/static/custom.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Interop: Principles, Techniques, and Tools</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="dispatching-an-asset-transfer"><a class="header" href="#dispatching-an-asset-transfer">Dispatching an Asset Transfer</a></h1>
<p>Let's dive into interoperability by performing a complex cross-chain operation programmatically. While this interoperability touches upon several technical concepts like asset standards, altVMs, indexing, light clients, and storage proofs, our main goal is to execute an end-to-end operation and understand the components involved. We'll explore the theoretical foundations in later chapters.</p>
<p>We will implement a TypeScript program that can manage EVM (Ethereum Virtual Machine) wallets, interact with multiple chains, and dispatch asset transfers through smart contract interactions. Finally, we will query an indexing service to trace our transfer's progress. While this code works in both frontend and backend environments thanks to TypeScript, we recommend Rust for production backends.</p>
<h2 id="setting-up-the-project"><a class="header" href="#setting-up-the-project">Setting up the project</a></h2>
<pre><code class="language-console">mkdir asset-dispatcher
</code></pre>
<p>Create a <code>flake.nix</code> with the following configuration. This sets up <a href="https://deno.com/">Deno</a> for your local development environment and adds code formatters (run with <code>nix fmt</code>). Enable the development environment by running <code>nix develop</code>.</p>
<pre><code class="language-nix">{
  description = "Example Union TypeScript SDK usage";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    flake-parts.url = "github:hercules-ci/flake-parts";
  };

  outputs =
    inputs@{ flake-parts, nixpkgs, ... }:
    flake-parts.lib.mkFlake { inherit inputs; } {
      systems = [
        "x86_64-linux"
        "aarch64-linux"
        "x86_64-darwin"
        "aarch64-darwin"
      ];
      perSystem =
        {
          config,
          self',
          inputs',
          pkgs,
          lib,
          system,
          ...
        }:
        let
          packageJson = lib.importJSON ./package.json;
        in
        {
          packages = {
            default = pkgs.buildNpmPackage {
              pname = packageJson.name;
              inherit (packageJson) version;
              src = ./.;
              npmDepsHash = "sha256-ZN47MDJes95+CXBoPaN4blpxP12ZS6trnUtm0+tYTqo=";

              postInstall = ''
                mkdir -p $out/bin
                cat &gt; $out/bin/${packageJson.name} &lt;&lt; EOF
                #!/usr/bin/env node
                require('../lib/node_modules/${packageJson.name}/dist/src/index.js')
                EOF
                chmod +x $out/bin/${packageJson.name}
              '';
            };
          };

          devShells.default = pkgs.mkShell {
            buildInputs = with pkgs; [
              nodejs
              nodePackages_latest.typescript-language-server
              biome
              nixfmt
            ];
          };
        };
    };
}
</code></pre>
<p>Next, create <code>src/index.ts</code>. This will contain most of our logic. Add a simple test:</p>
<pre><code class="language-typescript">console.log("hello, world");
</code></pre>
<p>Run it with <code>deno run src/index.ts</code> to verify your environment works. You should see <code>hello, world</code> in your terminal.</p>
<h2 id="managing-wallets"><a class="header" href="#managing-wallets">Managing wallets</a></h2>
<p>Let's modify <code>index.ts</code> to create and fund two wallets. Note: This example hardcodes mnemonics for demonstration purposes. In production, always use proper key management services.</p>
<pre><code class="language-typescript">import { createWalletClient, http } from "npm:viem";
import { mnemonicToAccount } from "npm:@viem/accounts";
import { sepolia, holesky } from "npm:viem/chains";

const sepoliaWallet = createWalletClient({
  account: mnemonicToAccount(memo),
  chain: sepolia,
  transport: http(),
});

const holeskyWallet = createWalletClient({
  account: mnemonicToAccount(memo),
  chain: holesky,
  transport: http(),
});

console.log(`Sepolia address: ${sepoliaWallet.account.address}`);
console.log(`Holesky address: ${holeskyWallet.account.address}`);
</code></pre>
<p>Create two variables, <code>mnemonic1</code> and <code>mnemonic2</code>, each containing a 12-word sentence (space-separated) as a string. Run the script and save your addresses. You can use the same mnemonic if you prefer.</p>
<p>To fund our Sepolia address for contract interactions, we'll use a <a href="https://www.alchemy.com/faucets/ethereum-sepolia">faucet</a>.</p>
<p>Let's verify our faucet funding by checking the balance:
create-client</p>
<pre><code class="language-typescript">import { createPublicClient, formatEther } from "npm:viem";

const sepoliaClient = createPublicClient({
  chain: sepolia,
  transport: http(),
});

const balance = await sepoliaClient.getBalance({
  address: sepoliaWallet.account.address,
});

console.log(`Sepolia balance: ${formatEther(balance)} ETH (${balance} wei)`);
</code></pre>
<p>We use <code>formatEther</code> for human-readable output. The parenthesized value shows the raw balance. We'll discuss sats, decimals, and asset standards later, but note that ETH is stored in wei on-chain (1 ETH = 10^18 wei).</p>
<p>At this point, we have secured testnet funds and set up a local wallet (though not production-ready).</p>
<h2 id="performing-the-asset-transfer"><a class="header" href="#performing-the-asset-transfer">Performing the Asset Transfer</a></h2>
<p>To do the bridge operation, we'll directly interact with the Union contracts through their ABI. We will use the Union <a href="https://www.npmjs.com/package/@unionlabs/sdk">SDK</a> package to import some types and the required ABIs. The sdk provides both low-level bindings to various contracts, as well as backend clients and effects based on <a href="https://effect.website/">effect.website</a>.</p>
<p>For now we are going to use the raw bindings, to show what happens under the hood. To perform an asset transfer, we need to perform 3 distinct steps:</p>
<ol>
<li>Gather configuration parameters.</li>
<li>Approve the contracts.</li>
<li>Sending the bridge transfer.</li>
</ol>
<p>For step 1. we will rely on etherscan and the Union API. In production you might want to store hardcoded mappings, or dynamically fetch these values from your own APIs. Constructing the transaction is simple for an asset transfer. This is also the stage where we might add 1-click swaps, or DEX integration later down the road.</p>
<p>Although step 3 seems trivial, it is actually quite annoying when dealing with multiple, independent ecosystems. That's why we are doing EVM to EVM for now, so we are only dealing with one execution environment implementation.</p>
<h3 id="configuration-parameters"><a class="header" href="#configuration-parameters">Configuration Parameters</a></h3>
<p>Since Union leverages channels, we will need to query the channel-id to use between Sepolia and Holesky. We're using the <code>ucs03-zkgm-0</code> protocol, so that's what we'll filter on. The <code>v2_channel_recommendations</code> shows officially supported channels by the Union team.</p>
<pre><code class="language-graphql">query Channels @cached(ttl: 60) {
  v1_ibc_union_channel_recommendations(where: { version: { _eq: "ucs03-zkgm-0" } }) {
    source_port_id
    source_chain_id
    source_channel_id
    source_connection_id
    destination_port_id
    destination_chain_id
    destination_channel_id
    destination_connection_id
  }
}
</code></pre>
<p>For our transfer, we are interested in the <code>source_channel_id</code> for Sepolia (<code>ethereum.11155111</code>).</p>
<p>Since we are doing a WETH transfer, we can use <a href="https://sepolia.etherscan.io/token/0x7b79995e5f793a07bc00c21412e50ecae098e7f9#readContract">etherscan</a> to find the asset parameters (symbol, decimals and name). Union does verify onchain that the provided parameters are correct. We do pass them to the contract because we want to calculate the packet hash ahead of time. You might wonder why we even use these values in the contract? That is to ensure that when Union instantiates a new asset on the destination chain, it is configured correctly (same symbol, decimals, and name).</p>
<p>Per chain, we can find the Union contracts <a href="https://github.com/unionlabs/union/blob/97e5e8346f824e482185953a6648ad8b9bed9ac3/deployments/deployments.json#L256">here</a>. For testnet deployments, these might be updated as of writing this book.</p>
<p>Finally we need to obtain the quote token address (the address of the asset on the destination side).</p>
<pre><code class="language-graphql">query GetTransferRequestDetails {
    get_transfer_request_details(args:{
        p_source_universal_chain_id: "ethereum.11155111",
        p_destination_universal_chain_id: "ethereum.17000",
        p_base_token: "0x7b79995e5f793A07Bc00c21412e50Ecae098E7f9"
    }) {
        quote_token
        source_channel_id
        destination_channel_id
        already_exists
        wrap_direction
    }
}

</code></pre>
<p>This should return</p>
<pre><code>{
  "data": {
    "get_wrapped_transfer_request_details": [
      {
        "quote_token": "0x685a6d912eced4bdd441e58f7c84732ceccbd1e4",
        "source_channel_id": 8,
        "destination_channel_id": 47,
        "already_exists": true
      }
    ]
  }
}
</code></pre>
<p>The <code>source_channel_id</code> should match the channel from the <code>v2_channel_recommendations</code> query.</p>
<p>The <code>quote_token</code> is deterministically generated depending on the contract addresses and channel_ids. If <code>already_exists</code> is false, the Union contract on the destination chain will instantiate a new asset, hence why the deterministically derived address algorithm is so important.</p>
<h2 id="approvals"><a class="header" href="#approvals">Approvals</a></h2>
<p>Under the hood, the Union contract will withdraw funds from our account before bridging them to Holesky. This withdrawal is normally not allowed (for security reasons, imagine if smart contracts were allowed to just remove user funds!), so we need to <code>approve</code> the Union contract to allow it to withdraw.</p>
<pre><code class="language-typescript">import { erc20Abi } from "viem";

await sepoliaWallet.writeContract({
  address: "0x7b79995e5f793A07Bc00c21412e50Ecae098E7f9",
  abi: erc20Abi,
  functionName: "approve",
  args: [ucs03address, 100000000000n],
});
</code></pre>
<p>For convenience, we are allowing the contract <code>MaxUint256</code>, so that we do not need to do further approvals. From now on, the Union ucs03 contract can withdraw WETH on Sepolia.</p>
<h2 id="bridging"><a class="header" href="#bridging">Bridging</a></h2>
<p>Executing the actual bridge operation seems like quite a lot of lines of code. Later we will use the alternative typescript client and effects API, to simplify the flow.</p>
<p>When we interact with the <code>send</code> entrypoint, we submit a program. Union's bridge standard leverages a lightweight, non-Turing complete VM. That way, we can do 1-click swaps, forwards, or other arbitrary logic. The <code>args</code> for our call in this case is the <code>Batch</code> instruction, which is effectively a list of instructions to execute. Inside the batch, we have two <code>FungibleAssetOrder</code>s. The first order is transferring wrapped Eth using a 1:1 ratio (meaning that on the receiving side, the user will receive 100% of the amount). The second order has a 1:0 ratio, meaning that the user receives nothing on the destination side. Effectively, we are 'tipping' the protocol here. An alternative way to ensure this transfer is funded, is altering the ratio of the first transfer. For example, a 100:99 ratio would be a 1% transfer fee.</p>
<pre><code class="language-typescript">import { Batch, FungibleAssetOrder } from "npm:@unionlabs/sdk/evm/ucs03";
import { ucs03abi } from "npm:@unionlabs/sdk/evm/abi";
import { toHex, type Hex } from "viem";

function generateSalt() {
  const rawSalt = new Uint8Array(32);
  crypto.getRandomValues(rawSalt);
  return toHex(rawSalt) as Hex;
}

let transferHash = await sepoliaWallet.writeContract({
  account: sepoliaWallet.account.address as `0x${string}`,
  abi: ucs03abi,
  chain: sepolia,
  functionName: "send",
  address: ucs03address,
  args: [
    // obtained from the graphql Channels query
    sourceChannelId,
    // this transfer is timeout out by timestamp, so we set height to 0.
    0n,
    // The actual timeout. It is current time + 2 hours.
    BigInt(Math.floor(Date.now() / 1000) + 7200),
    generateSalt(),
    // We're actually enqueuing two transfers, the main transfer, and fee.
    Batch([
      // Our main transfer.
      FungibleAssetOrder([
        sepoliaWallet.account.address,
        holeskyWallet.account.address,
        WETH_ADDRESS,
        4n,
        // symbol
        "WETH",
        // name
        "Wrapped Ether",
        // decimals
        18,
        // path
        0n,
        // quote token
        "0x685a6d912eced4bdd441e58f7c84732ceccbd1e4",
        // quote amount
        4n,
      ]),
      // Our fee transfer.
      FungibleAssetOrder([
        sepoliaWallet.account.address,
        holeskyWallet.account.address,
        WETH_ADDRESS,
        1n,
        // symbol
        "WETH",
        // name
        "Wrapped Ether",
        // decimals
        18,
        // path
        0n,
        // quote token
        "0x685a6d912eced4bdd441e58f7c84732ceccbd1e4",
        // quote amount
        0n,
      ]),
    ]),
  ],
});
</code></pre>
<p>The denomAddress is the ERC20 address of the asset we want to send. You might notice that regular ETH does not have an address, because it is not an ERC20. To perform the transfer, ETH must be wrapped to WETH (optional if you already own WETH):</p>
<pre><code class="language-typescript">import { parseEther } from "viem";

// WETH ABI - we only need the deposit function for wrapping
const WETH_ABI = [
  {
    name: "deposit",
    type: "function",
    stateMutability: "payable",
    inputs: [],
    outputs: [],
  },
] as const;

// Create the wallet client and transaction
const hash = await sepoliaWallet.writeContract({
  address: WETH_ADDRESS,
  abi: WETH_ABI,
  functionName: "deposit",
  value: parseEther("0.0001"), // Amount of ETH to wrap
});

console.log(`Wrapping ETH: ${hash}`);
</code></pre>
<p>Once this transaction is included, the transfer is enqueued and will be picked up by a solver. Next we should monitor the transfer progression using an indexer. The easiest solution is [graphql.union.build], which is powered by [<code>hubble</code>]. Later we will endeavour to obtain the data directly from public RPCs as well.</p>
<h2 id="tracking-transfer-progression"><a class="header" href="#tracking-transfer-progression">Tracking Transfer Progression</a></h2>
<p>Once the transfer is enqueued onchain, we go through a pipeline of backend operations, which normally are opaque to the enduser, but useful for us for debugging (and fun to look at). Union refers to these steps as <code>Traces</code>, and they are indexed and stored for us by Hubble. Some of these include:</p>
<ul>
<li><code>PACKET_SEND</code></li>
<li><code>PACKET_SEND_LC_UPDATE_L0</code></li>
<li><code>PACKET_RECV</code></li>
<li><code>PACKET_ACK</code></li>
</ul>
<p>The <code>PACKET_SEND</code> was actually us performing the transfer. The other steps are executed by solvers. Later we will write a solver to explore what each entails.</p>
<p>To get the tracing data, we'll make a <a href="https://graphql.org/">Graphql</a> query. For now we will just use <code>fetch</code> calls, but there are many high quality graphql clients around.</p>
<pre><code class="language-typescript">let query = `
  query {
      v2_transfers(where: {transfer_send_transaction_hash:{_eq: "${transferHash}"}}) {
          traces {
              type
              height
              chain { 
                  display_name
                  universal_chain_id
              }
          }
      }
  }`;

const response = await fetch("https://graphql.union.build", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    query,
    variables: {},
  }),
});

const data = await response.json();

console.log(data);
</code></pre>
<p>For example, for the transaction hash <code>0xa7389117b99b7de4dcd71dc2acbe21d42826dd4d35174c72f23c0adb64144863</code>, we get the following data:</p>
<pre><code class="language-json">{
  "data": {
    "v2_transfers": [
      {
        "traces": [
          {
            "type": "PACKET_SEND",
            "height": 7839514,
            "chain": {
              "display_name": "Sepolia",
              "universal_chain_id": "11155111.sepolia"
            }
          },
          {
            "type": "PACKET_SEND_LC_UPDATE_L0",
            "height": null,
            "chain": {
              "display_name": "Union Testnet 9",
              "universal_chain_id": "union-testnet-9.union"
            }
          },
          {
            "type": "PACKET_RECV",
            "height": null,
            "chain": {
              "display_name": "Union Testnet 9",
              "universal_chain_id": "union-testnet-9.union"
            }
          },
          {
            "type": "WRITE_ACK",
            "height": null,
            "chain": {
              "display_name": "Union Testnet 9",
              "universal_chain_id": "union-testnet-9.union"
            }
          },
          {
            "type": "WRITE_ACK_LC_UPDATE_L0",
            "height": null,
            "chain": {
              "display_name": "Sepolia",
              "universal_chain_id": "11155111.sepolia"
            }
          },
          {
            "type": "PACKET_ACK",
            "height": null,
            "chain": {
              "display_name": "Sepolia",
              "universal_chain_id": "11155111.sepolia"
            }
          }
        ]
      }
    ]
  }
}
</code></pre>
<p>Universal chain IDs are chain identifiers specifically used by Union, which are, as the name implies, universally unique. The reason for deviating from what the chains themselves use, is described <a href="./union/chain-ids.html">here</a>.</p>
<p>If we want to monitor the progression of a transfer, we would poll this query. There are three important trace types to watch for.</p>
<ul>
<li><code>PACKET_SEND</code>: our transaction was included on the source chain. From this moment on, explorer links using the transaction hash should return data. (on average, the Union API is about 5-10 seconds faster than Etherscan though.)</li>
<li><code>PACKET_RECV</code>: the relayer has submitted a proof and the packet for the transfer. Funds are now usable on the destination side. The transfer flow is now 'completed' from the user's perspective.</li>
<li><code>PACKET_ACK</code>: the relayer has acknowledged the transfer on the source chain. If the open-filling API was used, this event will also trigger payment for the solver. This is only of interest for solvers/backend engineers.</li>
</ul>
<p>Once we see the <code>PACKET_RECV</code> event, our funds will be usable on Holesky. The traces after that are used by the system to pay the solver, and maintain bookkeeping.</p>
<p>We can query Holesky for our balance to verify that we received funds:</p>
<pre><code class="language-typescript">

const holeskyClient = createPublicClient({
  chain: holesky,
  transport: http(),
});

const holeskyBalance = await holeskyClient.readContract({
  address: "0x685a6d912eced4bdd441e58f7c84732ceccbd1e4",
  abi: erc20Abi,
  functionName: "balanceOf",
  args: [holeskyWallet.account.address],
});

const formattedBalance = balance / 10n ** BigInt(18);

console.log(`Token balance: ${formattedBalance} (${holeskyBalance})`);
</code></pre>
<p>This should now return the amount sent in the first <code>FungibleAssetOrder</code>.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>This was a hands-on way to introduce you to multichain programming. We have ommitted the implementation details of many of the individual steps. You have now experienced the transfer flow that a regular user experiences when interacting through UIs. In the next chapter, we will go deeper into what each trace meant. Later we will write a simple solver, and show orders are filled.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="getting-started/apple/orbstack.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="union/overview.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="getting-started/apple/orbstack.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="union/overview.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/static/mermaid.min.js"></script>
        <script src="src/static/mermaid-init.js"></script>
        <script src="src/static/tab.js"></script>
        <script src="src/static/solidity.min.js"></script>


    </div>
    </body>
</html>
